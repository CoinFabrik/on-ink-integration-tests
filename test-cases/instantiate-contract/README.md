# Function `instantiate_contract`

```rust
pub fn instantiate_contract<E, ContractRef, Args, Salt, R>(
    params: &CreateParams<E, ContractRef, Args, Salt, R>
) -> Result<ConstructorResult<<R as ConstructorReturnType<ContractRef>>::Output>>
where
    E: Environment,
    ContractRef: FromAccountId<E>,
    Args: Encode,
    Salt: AsRef<[u8]>,
    R: ConstructorReturnType<ContractRef>,
```

## Description

`instantiate_contract` is a low level way to instantiate another smart contract.

## Related ink! functions

- [instantiate_contract](https://paritytech.github.io/ink/ink_env/fn.instantiate_contract.html)

## Test case



## Comparison Integration vs E2E

The End-to-End test works correctly since it invokes successfully the call to the second contract. In Integration did not work since it's [unimplemented](https://github.com/paritytech/ink/blob/c2af39883aab48c71dc09dac5d06583f2e84dc54/crates/env/src/engine/off_chain/impls.rs#L464).

| \#  | Test                                                            | Integration | E2E |
| --- | --------------------------------------------------------------- | :---------: | :-: |
| 1   | Attempts to instantiate a contract.                             |     ❌      | ✅  |

## Result

The implementation of instantiate_contract() is somewhat tied to that of code_hash and own_code_hash(). The strategy picked for one will condition the solution for the other. The simpler of the two may take up to roughly 15 days. There are some things to work out, such as how to call the required function, that add some uncertainty to the estimate.

## Update on Correcting this Issue

In order to allow contract instantiation, we modified the `instantiate_contract()` function in [PR #1988](https://github.com/paritytech/ink/pull/1988) to call the dispatch code generated by the ink! code generator. This way, `instantiate_contract()` can call contract constructors, allowing for the instantiation of contracts in integration tests. We also correctly keep track of callees as we move along the call stack, and set the code hash for the new contract account, as well as give it its endowment.

For correct behavior emulation, a test should call `ink::env::test::upload_code()` before calling `instantiate_contract()`, which will simulate uploading the code of a contract to the environment and giving back a code hash.

Something else worth noting is that we had to move the types under `ink::reflect` to the `ink_primitives` crate, since now both the ink and `ink_env` crates depend on those types and there was no other way to avoid a circular dependency.


**Observation 1**: 

In order to use contract instantiation in integration tests it is necessary to invoke cargo with:

```console
cargo test --features test_instantiate
```

This is necessary because getting back the return value of the constructor involved allowing the `execute_dispatchable()` function to return normally, but on-chain it never returns and instead the on-chain implementation of `return_value()` triggers a WASM trap that the runtime catches. In order to avoid changing the behavior of on-chain contracts, we preferred requiring enabling a feature just for off-chain tests, which modifies the signature of `return_value()` and allows a normal return from `execute_dispatchable()`.

**Observation 2**:
 
Initially, for Milestone 2,  we opened [PR  #1963](https://github.com/paritytech/ink/pull/1963) just for instantiate_contract(), since we internally organized our work separated by function. However, when we got to invoke_contract() in Milestone 3 we realized that these functions were too interconnected for separate PRs, so we decided to just have a single [PR #1988](https://github.com/paritytech/ink/pull/1988) for all of them. In the first [PR  #1963](https://github.com/paritytech/ink/pull/1963) we included a function set_contract_storage_test() in order to obtain the storage key of the contract, which we removed in the second [PR #1988](https://github.com/paritytech/ink/pull/1988) because we deemed it was not necessary.

